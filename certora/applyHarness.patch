diff -ruN BaseIRM.sol BaseIRM.sol
--- BaseIRM.sol	2021-09-07 11:35:53.363906379 -0400
+++ BaseIRM.sol	2021-10-07 17:41:13.401630936 -0400
@@ -5,7 +5,6 @@
 import "./BaseModule.sol";
 
 abstract contract BaseIRM is BaseModule {
-    constructor(uint moduleId_) BaseModule(moduleId_) {}
 
     function computeInterestRate(address, uint32) external virtual returns (int96);
 
diff -ruN BaseLogic.sol BaseLogic.sol
--- BaseLogic.sol	2021-09-14 11:02:38.937718289 -0400
+++ BaseLogic.sol	2021-10-07 17:41:13.401630936 -0400
@@ -11,8 +11,6 @@
 
 
 abstract contract BaseLogic is BaseModule {
-    constructor(uint moduleId_) BaseModule(moduleId_) {}
-
 
     // Account auth
 
@@ -29,12 +27,12 @@
 
     // Entered markets array
 
-    function _getEnteredMarketIndex(address account, address[MAX_POSSIBLE_ENTERED_MARKETS] storage markets, uint i) private view returns (address) {
+    function _getEnteredMarketIndex(address account, address[] storage markets, uint i) private view returns (address) {
         if (i == 0) return accountLookup[account].firstMarketEntered;
         else return markets[i];
     }
 
-    function _setEnteredMarketIndex(address account, address[MAX_POSSIBLE_ENTERED_MARKETS] storage markets, uint i, address underlying) private {
+    function _setEnteredMarketIndex(address account, address[] storage markets, uint i, address underlying) private {
         if (i == 0) accountLookup[account].firstMarketEntered = underlying;
         else markets[i] = underlying;
     }
@@ -42,7 +40,7 @@
     function getEnteredMarketsArray(address account) internal view returns (address[] memory) {
         uint32 numMarketsEntered = accountLookup[account].numMarketsEntered;
         address firstMarketEntered = accountLookup[account].firstMarketEntered;
-        address[MAX_POSSIBLE_ENTERED_MARKETS] storage markets = marketsEntered[account];
+        address[] storage markets = marketsEntered[account];
 
         address[] memory output = new address[](numMarketsEntered);
         if (numMarketsEntered == 0) return output;
@@ -62,7 +60,7 @@
 
         if (accountLookup[account].firstMarketEntered == underlying) return true;
 
-        address[MAX_POSSIBLE_ENTERED_MARKETS] storage markets = marketsEntered[account];
+        address[] storage markets = marketsEntered[account];
 
         for (uint i = 1; i < numMarketsEntered; i++) {
             if (markets[i] == underlying) return true;
@@ -73,7 +71,7 @@
 
     function doEnterMarket(address account, address underlying) internal {
         uint32 numMarketsEntered = accountLookup[account].numMarketsEntered;
-        address[MAX_POSSIBLE_ENTERED_MARKETS] storage markets = marketsEntered[account];
+        address[] storage markets = marketsEntered[account];
 
         for (uint i = 0; i < numMarketsEntered; i++) {
             if (_getEnteredMarketIndex(account, markets, i) == underlying) return; // already entered
@@ -91,7 +89,7 @@
 
     function doExitMarket(address account, address underlying) internal {
         uint32 numMarketsEntered = accountLookup[account].numMarketsEntered;
-        address[MAX_POSSIBLE_ENTERED_MARKETS] storage markets = marketsEntered[account];
+        address[] storage markets = marketsEntered[account];
         uint searchIndex = type(uint).max;
 
         for (uint i = 0; i < numMarketsEntered; i++) {
@@ -142,7 +140,7 @@
         uint40 lastInterestAccumulatorUpdate;
         uint8 underlyingDecimals;
         uint32 interestRateModel;
-        int96 interestRate;
+        uint96 interestRate;
         uint32 reserveFee;
         uint16 pricingType;
         uint32 pricingParameters;
@@ -153,6 +151,7 @@
         uint maxExternalAmount;
     }
 
+    
     function initAssetCache(address underlying, AssetStorage storage assetStorage, AssetCache memory assetCache) internal view returns (bool dirty) {
         dirty = false;
 
@@ -161,7 +160,7 @@
         // Storage loads
 
         assetCache.lastInterestAccumulatorUpdate = assetStorage.lastInterestAccumulatorUpdate;
-        uint8 underlyingDecimals = assetCache.underlyingDecimals = assetStorage.underlyingDecimals;
+        assetCache.underlyingDecimals = assetStorage.underlyingDecimals;
         assetCache.interestRateModel = assetStorage.interestRateModel;
         assetCache.interestRate = assetStorage.interestRate;
         assetCache.reserveFee = assetStorage.reserveFee;
@@ -177,8 +176,19 @@
 
         // Derived state
 
+        computeDerivedState(assetCache);
+
+        // Update interest accumulator and reserves
+
+        if (block.timestamp != assetCache.lastInterestAccumulatorUpdate) {
+            dirty = true;
+            accrueInterest(assetCache);
+        }
+    }
+
+    function computeDerivedState(AssetCache memory assetCache) virtual view internal {
         unchecked {
-            assetCache.underlyingDecimalsScaler = 10**(18 - underlyingDecimals);
+            assetCache.underlyingDecimalsScaler = 10**(18 - assetCache.underlyingDecimals);
             assetCache.maxExternalAmount = MAX_SANE_AMOUNT / assetCache.underlyingDecimalsScaler;
         }
 
@@ -188,43 +198,41 @@
         } else {
             assetCache.poolSize = 0;
         }
+    }
 
-        // Update interest accumulator and reserves
+    function accrueInterest(AssetCache memory assetCache) virtual view internal { 
 
-        if (block.timestamp != assetCache.lastInterestAccumulatorUpdate) {
-            dirty = true;
 
-            uint deltaT = block.timestamp - assetCache.lastInterestAccumulatorUpdate;
+        uint deltaT = block.timestamp - assetCache.lastInterestAccumulatorUpdate;
 
-            // Compute new values
+        // Compute new values
 
-            uint newInterestAccumulator = (RPow.rpow(uint(int(assetCache.interestRate) + 1e27), deltaT, 1e27) * assetCache.interestAccumulator) / 1e27;
+        uint newInterestAccumulator = (RPow.rpow(uint(int(assetCache.interestRate) + 1e27), deltaT, 1e27) * assetCache.interestAccumulator) / 1e27;
 
-            uint newTotalBorrows = assetCache.totalBorrows * newInterestAccumulator / assetCache.interestAccumulator;
+        uint newTotalBorrows = assetCache.totalBorrows * newInterestAccumulator / assetCache.interestAccumulator;
 
-            uint newReserveBalance = assetCache.reserveBalance;
-            uint newTotalBalances = assetCache.totalBalances;
+        uint newReserveBalance = assetCache.reserveBalance;
+        uint newTotalBalances = assetCache.totalBalances;
 
-            uint feeAmount = (newTotalBorrows - assetCache.totalBorrows)
-                               * (assetCache.reserveFee == type(uint32).max ? DEFAULT_RESERVE_FEE : assetCache.reserveFee)
-                               / (RESERVE_FEE_SCALE * INTERNAL_DEBT_PRECISION);
+        uint feeAmount = (newTotalBorrows - assetCache.totalBorrows)
+                            * (assetCache.reserveFee == type(uint32).max ? DEFAULT_RESERVE_FEE : assetCache.reserveFee)
+                            / (RESERVE_FEE_SCALE * INTERNAL_DEBT_PRECISION);
 
-            if (feeAmount != 0) {
-                uint poolAssets = assetCache.poolSize + (newTotalBorrows / INTERNAL_DEBT_PRECISION);
-                newTotalBalances = poolAssets * newTotalBalances / (poolAssets - feeAmount);
-                newReserveBalance += newTotalBalances - assetCache.totalBalances;
-            }
+        if (feeAmount != 0) {
+            uint poolAssets = assetCache.poolSize + (newTotalBorrows / INTERNAL_DEBT_PRECISION);
+            newTotalBalances = poolAssets * newTotalBalances / (poolAssets - feeAmount);
+            newReserveBalance += newTotalBalances - assetCache.totalBalances;
+        }
 
-            // Store new values in assetCache
+        // Store new values in assetCache
 
-            assetCache.totalBorrows = encodeDebtAmount(newTotalBorrows);
-            assetCache.interestAccumulator = newInterestAccumulator;
-            assetCache.lastInterestAccumulatorUpdate = uint40(block.timestamp);
-
-            if (newTotalBalances != assetCache.totalBalances) {
-                assetCache.reserveBalance = encodeSmallAmount(newReserveBalance);
-                assetCache.totalBalances = encodeAmount(newTotalBalances);
-            }
+        assetCache.totalBorrows = encodeDebtAmount(newTotalBorrows);
+        assetCache.interestAccumulator = newInterestAccumulator;
+        assetCache.lastInterestAccumulatorUpdate = uint40(block.timestamp);
+
+        if (newTotalBalances != assetCache.totalBalances) {
+            assetCache.reserveBalance = encodeSmallAmount(newReserveBalance);
+            assetCache.totalBalances = encodeAmount(newTotalBalances);
         }
     }
 
@@ -239,6 +247,7 @@
             assetStorage.totalBorrows = assetCache.totalBorrows;
 
             assetStorage.interestAccumulator = assetCache.interestAccumulator;
+
         }
     }
 
@@ -247,10 +256,9 @@
     }
 
 
-
     // Utils
 
-    function decodeExternalAmount(AssetCache memory assetCache, uint externalAmount) internal pure returns (uint scaledAmount) {
+    function decodeExternalAmount(AssetCache memory assetCache, uint externalAmount) internal view returns (uint scaledAmount) {
         require(externalAmount <= assetCache.maxExternalAmount, "e/amount-too-large");
         unchecked { scaledAmount = externalAmount * assetCache.underlyingDecimalsScaler; }
     }
@@ -270,17 +278,21 @@
         return uint144(amount);
     }
 
-    function computeExchangeRate(AssetCache memory assetCache) private pure returns (uint) {
+    function _computeExchangeRate(uint poolSize, uint totalBorrows, uint totalBalances) private pure returns (uint) {
+        return (poolSize + (totalBorrows / INTERNAL_DEBT_PRECISION)) * 1e18 / totalBalances;
+    }
+
+    function computeExchangeRate(AssetCache memory assetCache) private view returns (uint) {
         if (assetCache.totalBalances == 0) return 1e18;
-        return (assetCache.poolSize + (assetCache.totalBorrows / INTERNAL_DEBT_PRECISION)) * 1e18 / assetCache.totalBalances;
+        return _computeExchangeRate(assetCache.poolSize, assetCache.totalBorrows, assetCache.totalBalances);
     }
 
-    function balanceFromUnderlyingAmount(AssetCache memory assetCache, uint amount) internal pure returns (uint) {
+    function balanceFromUnderlyingAmount(AssetCache memory assetCache, uint amount) internal view returns (uint) {
         uint exchangeRate = computeExchangeRate(assetCache);
         return amount * 1e18 / exchangeRate;
     }
 
-    function balanceToUnderlyingAmount(AssetCache memory assetCache, uint amount) internal pure returns (uint) {
+    function balanceToUnderlyingAmount(AssetCache memory assetCache, uint amount) internal view returns (uint) {
         uint exchangeRate = computeExchangeRate(assetCache);
         return amount * exchangeRate / 1e18;
     }
@@ -304,26 +316,31 @@
         return abi.decode(data, (uint256));
     }
 
+    function computeUtilisation(uint totalBorrows, uint poolAssets) private pure returns (uint32) {
+        return uint32(totalBorrows * (uint(type(uint32).max) * 1e18) / poolAssets / 1e18);
+    }
+
+    uint96 _newInterestRate;
     function updateInterestRate(AssetStorage storage assetStorage, AssetCache memory assetCache) internal {
         uint32 utilisation;
 
-        {
+        /*{
             uint totalBorrows = assetCache.totalBorrows / INTERNAL_DEBT_PRECISION;
             uint poolAssets = assetCache.poolSize + totalBorrows;
             if (poolAssets == 0) utilisation = 0; // empty pool arbitrarily given utilisation of 0
-            else utilisation = uint32(totalBorrows * (uint(type(uint32).max) * 1e18) / poolAssets / 1e18);
+            else utilisation = computeUtilisation(totalBorrows, poolAssets);
         }
 
-        bytes memory result = callInternalModule(assetCache.interestRateModel,
-                                                 abi.encodeWithSelector(BaseIRM.computeInterestRate.selector, assetCache.underlying, utilisation));
-
-        (int96 newInterestRate) = abi.decode(result, (int96));
+        //bytes memory result = callInternalModule(assetCache.interestRateModel,
+        //                                         abi.encodeWithSelector(BaseIRM.computeInterestRate.selector, assetCache.underlying, utilisation));
+*/
+        (uint96 newInterestRate) = _newInterestRate; //abi.decode(result, (int96));
 
         assetStorage.interestRate = assetCache.interestRate = newInterestRate;
     }
 
     function logAssetStatus(AssetCache memory a) internal {
-        emit AssetStatus(a.underlying, a.totalBalances, a.totalBorrows / INTERNAL_DEBT_PRECISION, a.reserveBalance, a.poolSize, a.interestAccumulator, a.interestRate, block.timestamp);
+        //emit AssetStatus(a.underlying, a.totalBalances, a.totalBorrows / INTERNAL_DEBT_PRECISION, a.reserveBalance, a.poolSize, a.interestAccumulator, a.interestRate, block.timestamp);
     }
 
 
@@ -362,10 +379,10 @@
 
         assetStorage.users[from].balance = encodeAmount(origFromBalance - amount);
         assetStorage.users[to].balance = encodeAmount(assetStorage.users[to].balance + amount);
-
+/*
         emit Withdraw(assetCache.underlying, from, amount);
         emit Deposit(assetCache.underlying, to, amount);
-        emitViaProxy_Transfer(eTokenAddress, from, to, amount);
+        emitViaProxy_Transfer(eTokenAddress, from, to, amount);*/
     }
 
 
@@ -380,20 +397,20 @@
         if (owed == 0) return 0;
 
         // Can't divide by 0 here: If owed is non-zero, we must've initialised the user's interestAccumulator
-        return owed * assetCache.interestAccumulator / assetStorage.users[account].interestAccumulator;
+        return owed; // * assetCache.interestAccumulator / assetStorage.users[account].interestAccumulator;
     }
 
     // When non-zero, we round *up* to the smallest external unit so that outstanding dust in a loan can be repaid.
     // unchecked is OK here since owed is always loaded from storage, so we know it fits into a uint144 (pre-interest accural)
     // Takes and returns 27 decimals precision.
 
-    function roundUpOwed(AssetCache memory assetCache, uint owed) private pure returns (uint) {
+    function roundUpOwed(AssetCache memory assetCache, uint owed) private view returns (uint) {
         if (owed == 0) return 0;
-
+        return owed;/*
         unchecked {
             uint scale = INTERNAL_DEBT_PRECISION * assetCache.underlyingDecimalsScaler;
             return (owed + scale - 1) / scale * scale;
-        }
+        }*/
     }
 
     // Returns 18-decimals precision (debt amount is rounded up)
@@ -412,7 +429,7 @@
     }
 
     function logBorrowChange(AssetCache memory assetCache, address dTokenAddress, address account, uint prevOwed, uint owed) private {
-        prevOwed = roundUpOwed(assetCache, prevOwed) / INTERNAL_DEBT_PRECISION;
+       /* prevOwed = roundUpOwed(assetCache, prevOwed) / INTERNAL_DEBT_PRECISION;
         owed = roundUpOwed(assetCache, owed) / INTERNAL_DEBT_PRECISION;
 
         if (owed > prevOwed) {
@@ -423,7 +440,7 @@
             uint change = prevOwed - owed;
             emit Repay(assetCache.underlying, account, change);
             emitViaProxy_Transfer(dTokenAddress, account, address(0), change);
-        }
+        }*/
     }
 
     function increaseBorrow(AssetStorage storage assetStorage, AssetCache memory assetCache, address dTokenAddress, address account, uint amount) internal {
@@ -514,7 +531,7 @@
     function pullTokens(AssetCache memory assetCache, address from, uint amount) internal returns (uint amountTransferred) {
         uint poolSizeBefore = assetCache.poolSize;
 
-        Utils.safeTransferFrom(assetCache.underlying, from, address(this), amount / assetCache.underlyingDecimalsScaler);
+        Utils.safeTransferFrom(assetCache.underlying, from, address(this), amount /* assetCache.underlyingDecimalsScaler */);
         uint poolSizeAfter = assetCache.poolSize = decodeExternalAmount(assetCache, callBalanceOf(assetCache, address(this)));
 
         require(poolSizeAfter >= poolSizeBefore, "e/negative-transfer-amount");
@@ -524,7 +541,7 @@
     function pushTokens(AssetCache memory assetCache, address to, uint amount) internal returns (uint amountTransferred) {
         uint poolSizeBefore = assetCache.poolSize;
 
-        Utils.safeTransfer(assetCache.underlying, to, amount / assetCache.underlyingDecimalsScaler);
+        Utils.safeTransfer(assetCache.underlying, to, amount/* / assetCache.underlyingDecimalsScaler*/);
         uint poolSizeAfter = assetCache.poolSize = decodeExternalAmount(assetCache, callBalanceOf(assetCache, address(this)));
 
         require(poolSizeBefore >= poolSizeAfter, "e/negative-transfer-amount");
@@ -541,9 +558,11 @@
         return abi.decode(result, (uint));
     }
 
+    IRiskManager.LiquidityStatus _status;
+
     function getAccountLiquidity(address account) internal returns (uint collateralValue, uint liabilityValue) {
-        bytes memory result = callInternalModule(MODULEID__RISK_MANAGER, abi.encodeWithSelector(IRiskManager.computeLiquidity.selector, account));
-        (IRiskManager.LiquidityStatus memory status) = abi.decode(result, (IRiskManager.LiquidityStatus));
+        //bytes memory result = callInternalModule(MODULEID__RISK_MANAGER, abi.encodeWithSelector(IRiskManager.computeLiquidity.selector, account));
+        (IRiskManager.LiquidityStatus memory status) = _status; //abi.decode(result, (IRiskManager.LiquidityStatus));
 
         collateralValue = status.collateralValue;
         liabilityValue = status.liabilityValue;
@@ -552,7 +571,7 @@
     function checkLiquidity(address account) internal {
         if (accountLookup[account].liquidityCheckInProgress) return;
 
-        callInternalModule(MODULEID__RISK_MANAGER, abi.encodeWithSelector(IRiskManager.requireLiquidity.selector, account));
+    //    callInternalModule(MODULEID__RISK_MANAGER, abi.encodeWithSelector(IRiskManager.requireLiquidity.selector, account));
     }
 
 
@@ -584,6 +603,8 @@
         return computeNewAverageLiquidity(account, deltaT);
     }
 
+    mapping(address => mapping(uint => uint)) _averageLiquidity;
+
     function updateAverageLiquidity(address account) internal {
         uint lastAverageLiquidityUpdate = accountLookup[account].lastAverageLiquidityUpdate;
         if (lastAverageLiquidityUpdate == 0) return;
@@ -592,6 +613,6 @@
         if (deltaT == 0) return;
 
         accountLookup[account].lastAverageLiquidityUpdate = uint40(block.timestamp);
-        accountLookup[account].averageLiquidity = computeNewAverageLiquidity(account, deltaT);
+        accountLookup[account].averageLiquidity = _averageLiquidity[account][deltaT]; //computeNewAverageLiquidity(account, deltaT);
     }
 }
Binary files .BaseLogic.sol.swp and .BaseLogic.sol.swp differ
diff -ruN BaseModule.sol BaseModule.sol
--- BaseModule.sol	2021-09-07 11:38:22.724302735 -0400
+++ BaseModule.sol	2021-10-07 17:41:13.401630936 -0400
@@ -10,8 +10,11 @@
 
     uint immutable public moduleId; // public accessor common to all modules
 
-    constructor(uint moduleId_) {
-        moduleId = moduleId_;
+    // We need to remove the argument because we use diamond inheritance for the
+    // CVT harness.  Since the constructor cannot be called with different
+    // arguments in the different intermediate classes, we remove the argument.
+    constructor() {
+        moduleId = 0;
     }
 
 
@@ -42,24 +45,10 @@
     // Emit logs via proxies
 
     function emitViaProxy_Transfer(address proxyAddr, address from, address to, uint value) internal virtual {
-        (bool success,) = proxyAddr.call(abi.encodePacked(
-                               uint8(3),
-                               keccak256(bytes('Transfer(address,address,uint256)')),
-                               bytes32(uint(uint160(from))),
-                               bytes32(uint(uint160(to))),
-                               value
-                          ));
-        require(success, "e/log-proxy-fail");
+     
     }
 
     function emitViaProxy_Approval(address proxyAddr, address owner, address spender, uint value) internal virtual {
-        (bool success,) = proxyAddr.call(abi.encodePacked(
-                               uint8(3),
-                               keccak256(bytes('Approval(address,address,uint256)')),
-                               bytes32(uint(uint160(owner))),
-                               bytes32(uint(uint160(spender))),
-                               value
-                          ));
-        require(success, "e/log-proxy-fail");
+       
     }
 }
diff -ruN Constants.sol Constants.sol
--- Constants.sol	2021-09-07 11:35:53.363906379 -0400
+++ Constants.sol	2021-10-07 17:41:13.401630936 -0400
@@ -9,7 +9,7 @@
     uint internal constant MAX_SANE_SMALL_AMOUNT = type(uint96).max;
     uint internal constant MAX_SANE_DEBT_AMOUNT = type(uint144).max;
     uint internal constant INTERNAL_DEBT_PRECISION = 1e9;
-    uint internal constant MAX_ENTERED_MARKETS = 10; // per sub-account
+    uint internal constant MAX_ENTERED_MARKETS = 3; // per sub-account
     uint internal constant MAX_POSSIBLE_ENTERED_MARKETS = 2**32; // limited by size of AccountStorage.numMarketsEntered
     uint internal constant CONFIG_FACTOR_SCALE = 4_000_000_000; // must fit into a uint32
     uint internal constant RESERVE_FEE_SCALE = 4_000_000_000; // must fit into a uint32
diff -ruN .gitignore .gitignore
--- .gitignore	1969-12-31 19:00:00.000000000 -0500
+++ .gitignore	2021-10-07 17:34:06.023581779 -0400
@@ -0,0 +1,2 @@
+*
+!.gitignore
diff -ruN modules/DToken.sol modules/DToken.sol
--- modules/DToken.sol	2021-09-07 11:38:22.724302735 -0400
+++ modules/DToken.sol	2021-10-07 17:41:13.405630723 -0400
@@ -7,7 +7,6 @@
 
 /// @notice Tokenised representation of debts
 contract DToken is BaseLogic {
-    constructor() BaseLogic(MODULEID__DTOKEN) {}
 
     function CALLER() virtual internal view returns (address underlying, AssetStorage storage assetStorage, address proxyAddr, address msgSender) {
         (msgSender, proxyAddr) = unpackTrailingParams();
@@ -20,33 +19,33 @@
 
     // Events
 
-    event Transfer(address indexed from, address indexed to, uint256 value);
-    event Approval(address indexed owner, address indexed spender, uint256 value);
+    // event Transfer(address indexed from, address indexed to, uint256 value);
+    // event Approval(address indexed owner, address indexed spender, uint256 value);
 
 
 
     // External methods
 
     /// @notice Debt token name, ie "Euler Debt: DAI"
-    function name() external view returns (string memory) {
+    function name() public virtual view returns (string memory) {
         (address underlying,,,) = CALLER();
         return string(abi.encodePacked("Euler Debt: ", IERC20(underlying).name()));
     }
 
     /// @notice Debt token symbol, ie "dDAI"
-    function symbol() external view returns (string memory) {
+    function symbol() public virtual view returns (string memory) {
         (address underlying,,,) = CALLER();
         return string(abi.encodePacked("d", IERC20(underlying).symbol()));
     }
 
     /// @notice Decimals, always normalised to 18.
-    function decimals() external pure returns (uint8) {
+    function decimals() public virtual view returns (uint8) {
         return 18;
     }
 
 
     /// @notice Sum of all outstanding debts, in underlying units (increases as interest is accrued)
-    function totalSupply() external view returns (uint) {
+    function totalSupply() public virtual view returns (uint) {
         (address underlying, AssetStorage storage assetStorage,,) = CALLER();
         AssetCache memory assetCache = loadAssetCacheRO(underlying, assetStorage);
 
@@ -63,7 +62,7 @@
 
 
     /// @notice Debt owed by a particular account, in underlying units
-    function balanceOf(address account) external view returns (uint) {
+    function balanceOf(address account) public virtual view returns (uint) {
         (address underlying, AssetStorage storage assetStorage,,) = CALLER();
         AssetCache memory assetCache = loadAssetCacheRO(underlying, assetStorage);
 
@@ -87,7 +86,7 @@
         address account = getSubAccount(msgSender, subAccountId);
 
         updateAverageLiquidity(account);
-        emit RequestBorrow(account, amount);
+        // emit RequestBorrow(account, amount);
 
         AssetCache memory assetCache = loadAssetCache(underlying, assetStorage);
 
@@ -115,7 +114,7 @@
         address account = getSubAccount(msgSender, subAccountId);
 
         updateAverageLiquidity(account);
-        emit RequestRepay(account, amount);
+        // emit RequestRepay(account, amount);
 
         AssetCache memory assetCache = loadAssetCache(underlying, assetStorage);
 
@@ -138,7 +137,7 @@
     /// @notice Allow spender to send an amount of dTokens to your sub-account 0
     /// @param spender Trusted address
     /// @param amount Use max uint256 for "infinite" allowance
-    function approve(address spender, uint amount) external reentrantOK returns (bool) {
+    function approve(address spender, uint amount) public virtual reentrantOK returns (bool) {
         return approveSubAccount(0, spender, amount);
     }
 
@@ -146,7 +145,7 @@
     /// @param subAccountId 0 for primary, 1-255 for a sub-account
     /// @param spender Trusted address
     /// @param amount Use max uint256 for "infinite" allowance
-    function approveSubAccount(uint subAccountId, address spender, uint amount) public reentrantOK returns (bool) {
+    function approveSubAccount(uint subAccountId, address spender, uint amount) virtual public reentrantOK returns (bool) {
         (, AssetStorage storage assetStorage, address proxyAddr, address msgSender) = CALLER();
         address account = getSubAccount(msgSender, subAccountId);
 
@@ -161,7 +160,7 @@
     /// @notice Retrieve the current allowance
     /// @param holder Xor with the desired sub-account ID (if applicable)
     /// @param spender Trusted address
-    function allowance(address holder, address spender) external view returns (uint) {
+    function allowance(address holder, address spender) public virtual view returns (uint) {
         (, AssetStorage storage assetStorage,,) = CALLER();
 
         return assetStorage.dTokenAllowance[holder][spender];
@@ -172,7 +171,7 @@
     /// @notice Transfer dTokens to another address (from sub-account 0)
     /// @param to Xor with the desired sub-account ID (if applicable)
     /// @param amount In underlying units. Use max uint256 for full balance.
-    function transfer(address to, uint amount) external returns (bool) {
+    function transfer(address to, uint amount) public virtual returns (bool) {
         return transferFrom(address(0), to, amount);
     }
 
@@ -180,7 +179,7 @@
     /// @param from Xor with the desired sub-account ID (if applicable)
     /// @param to This address must've approved the from address, or be a sub-account of msg.sender
     /// @param amount In underlying. Use max uint256 for full balance.
-    function transferFrom(address from, address to, uint amount) public nonReentrant returns (bool) {
+    function transferFrom(address from, address to, uint amount) public virtual nonReentrant returns (bool) {
         (address underlying, AssetStorage storage assetStorage, address proxyAddr, address msgSender) = CALLER();
         AssetCache memory assetCache = loadAssetCache(underlying, assetStorage);
 
@@ -189,7 +188,7 @@
 
         updateAverageLiquidity(from);
         updateAverageLiquidity(to);
-        emit RequestTransferDToken(from, to, amount);
+        // emit RequestTransferDToken(from, to, amount);
 
         if (amount == type(uint).max) amount = getCurrentOwed(assetStorage, assetCache, from);
         else amount = decodeExternalAmount(assetCache, amount);
diff -ruN modules/EToken.sol modules/EToken.sol
--- modules/EToken.sol	2021-09-14 11:02:38.937718289 -0400
+++ modules/EToken.sol	2021-10-07 17:41:13.405630723 -0400
@@ -7,7 +7,6 @@
 
 /// @notice Tokenised representation of assets
 contract EToken is BaseLogic {
-    constructor() BaseLogic(MODULEID__ETOKEN) {}
 
     function CALLER() virtual internal view returns (address underlying, AssetStorage storage assetStorage, address proxyAddr, address msgSender) {
         (msgSender, proxyAddr) = unpackTrailingParams();
@@ -19,34 +18,34 @@
 
     // Events
 
-    event Transfer(address indexed from, address indexed to, uint256 value);
-    event Approval(address indexed owner, address indexed spender, uint256 value);
+    // event Transfer(address indexed from, address indexed to, uint256 value);
+    // event Approval(address indexed owner, address indexed spender, uint256 value);
 
 
 
     // External methods
 
     /// @notice Pool name, ie "Euler Pool: DAI"
-    function name() external view returns (string memory) {
+    function name() public virtual view returns (string memory) {
         (address underlying,,,) = CALLER();
         return string(abi.encodePacked("Euler Pool: ", IERC20(underlying).name()));
     }
 
     /// @notice Pool symbol, ie "eDAI"
-    function symbol() external view returns (string memory) {
+    function symbol() public virtual view returns (string memory) {
         (address underlying,,,) = CALLER();
         return string(abi.encodePacked("e", IERC20(underlying).symbol()));
     }
 
     /// @notice Decimals, always normalised to 18.
-    function decimals() external pure returns (uint8) {
+    function decimals() public virtual view returns (uint8) {
         return 18;
     }
 
 
 
     /// @notice Sum of all balances, in internal book-keeping units (non-increasing)
-    function totalSupply() external view returns (uint) {
+    function totalSupply() public virtual view returns (uint) {
         (address underlying, AssetStorage storage assetStorage,,) = CALLER();
         AssetCache memory assetCache = loadAssetCacheRO(underlying, assetStorage);
 
@@ -63,7 +62,7 @@
 
 
     /// @notice Balance of a particular account, in internal book-keeping units (non-increasing)
-    function balanceOf(address account) external view returns (uint) {
+    function balanceOf(address account) public virtual view returns (uint) {
         (, AssetStorage storage assetStorage,,) = CALLER();
 
         return assetStorage.users[account].balance;
@@ -94,7 +93,6 @@
         return balanceToUnderlyingAmount(assetCache, assetCache.reserveBalance) / assetCache.underlyingDecimalsScaler;
     }
 
-
     /// @notice Transfer underlying tokens from sender to the Euler pool, and increase account's eTokens
     /// @param subAccountId 0 for primary, 1-255 for a sub-account
     /// @param amount In underlying units (use max uint256 for full underlying token balance)
@@ -103,7 +101,7 @@
         address account = getSubAccount(msgSender, subAccountId);
 
         updateAverageLiquidity(account);
-        emit RequestDeposit(account, amount);
+        //emit RequestDeposit(account, amount);
 
         AssetCache memory assetCache = loadAssetCache(underlying, assetStorage);
 
@@ -140,7 +138,7 @@
         address account = getSubAccount(msgSender, subAccountId);
 
         updateAverageLiquidity(account);
-        emit RequestWithdraw(account, amount);
+        //emit RequestWithdraw(account, amount);
 
         AssetCache memory assetCache = loadAssetCache(underlying, assetStorage);
 
@@ -173,7 +171,7 @@
         address account = getSubAccount(msgSender, subAccountId);
 
         updateAverageLiquidity(account);
-        emit RequestMint(account, amount);
+        //emit RequestMint(account, amount);
 
         AssetCache memory assetCache = loadAssetCache(underlying, assetStorage);
 
@@ -199,7 +197,7 @@
         address account = getSubAccount(msgSender, subAccountId);
 
         updateAverageLiquidity(account);
-        emit RequestBurn(account, amount);
+        //emit RequestBurn(account, amount);
 
         AssetCache memory assetCache = loadAssetCache(underlying, assetStorage);
 
@@ -228,7 +226,7 @@
     /// @notice Allow spender to access an amount of your eTokens in sub-account 0
     /// @param spender Trusted address
     /// @param amount Use max uint256 for "infinite" allowance
-    function approve(address spender, uint amount) external reentrantOK returns (bool) {
+    function approve(address spender, uint amount) public virtual reentrantOK returns (bool) {
         return approveSubAccount(0, spender, amount);
     }
 
@@ -236,7 +234,7 @@
     /// @param subAccountId 0 for primary, 1-255 for a sub-account
     /// @param spender Trusted address
     /// @param amount Use max uint256 for "infinite" allowance
-    function approveSubAccount(uint subAccountId, address spender, uint amount) public reentrantOK returns (bool) {
+    function approveSubAccount(uint subAccountId, address spender, uint amount) virtual public reentrantOK returns (bool) {
         (, AssetStorage storage assetStorage, address proxyAddr, address msgSender) = CALLER();
         address account = getSubAccount(msgSender, subAccountId);
 
@@ -251,7 +249,7 @@
     /// @notice Retrieve the current allowance
     /// @param holder Xor with the desired sub-account ID (if applicable)
     /// @param spender Trusted address
-    function allowance(address holder, address spender) external view returns (uint) {
+    function allowance(address holder, address spender) public virtual view returns (uint) {
         (, AssetStorage storage assetStorage,,) = CALLER();
 
         return assetStorage.eTokenAllowance[holder][spender];
@@ -263,7 +261,7 @@
     /// @notice Transfer eTokens to another address (from sub-account 0)
     /// @param to Xor with the desired sub-account ID (if applicable)
     /// @param amount In internal book-keeping units (as returned from balanceOf). Use max uint256 for full balance.
-    function transfer(address to, uint amount) external returns (bool) {
+    function transfer(address to, uint amount) public virtual returns (bool) {
         return transferFrom(address(0), to, amount);
     }
 
@@ -271,7 +269,7 @@
     /// @param from This address must've approved the to address, or be a sub-account of msg.sender
     /// @param to Xor with the desired sub-account ID (if applicable)
     /// @param amount In internal book-keeping units (as returned from balanceOf). Use max uint256 for full balance.
-    function transferFrom(address from, address to, uint amount) public nonReentrant returns (bool) {
+    function transferFrom(address from, address to, uint amount) public virtual nonReentrant returns (bool) {
         (address underlying, AssetStorage storage assetStorage, address proxyAddr, address msgSender) = CALLER();
 
         AssetCache memory assetCache = loadAssetCache(underlying, assetStorage);
@@ -281,7 +279,7 @@
 
         updateAverageLiquidity(from);
         updateAverageLiquidity(to);
-        emit RequestTransferEToken(from, to, amount);
+        //emit RequestTransferEToken(from, to, amount);
 
         if (amount == type(uint).max) amount = assetStorage.users[from].balance;
 
diff -ruN modules/Exec.sol modules/Exec.sol
--- modules/Exec.sol	2021-09-07 11:35:53.363906379 -0400
+++ modules/Exec.sol	2021-10-07 17:41:13.405630723 -0400
@@ -2,7 +2,7 @@
 
 pragma solidity ^0.8.0;
 
-import "../BaseLogic.sol";
+import "../../harness/BaseHarness.sol";
 import "../IRiskManager.sol";
 import "../PToken.sol";
 import "../Interfaces.sol";
@@ -16,7 +16,7 @@
 
 
 /// @notice Batch executions, liquidity check deferrals, and interfaces to fetch prices and account liquidity
-contract Exec is BaseLogic {
+contract Exec is BaseHarness {
     constructor() BaseLogic(MODULEID__EXEC) {}
 
     /// @notice Single item in a batch request
diff -ruN modules/Governance.sol modules/Governance.sol
--- modules/Governance.sol	2021-09-07 11:35:53.363906379 -0400
+++ modules/Governance.sol	2021-10-07 17:41:13.405630723 -0400
@@ -2,11 +2,11 @@
 
 pragma solidity ^0.8.0;
 
-import "../BaseLogic.sol";
+import "../../harness/BaseHarness.sol";
 import "../BaseIRM.sol";
 
 
-contract Governance is BaseLogic {
+contract Governance is BaseHarness {
     constructor() BaseLogic(MODULEID__GOVERNANCE) {}
 
     modifier governorOnly {
diff -ruN modules/Installer.sol modules/Installer.sol
--- modules/Installer.sol	2021-09-07 11:38:22.724302735 -0400
+++ modules/Installer.sol	2021-10-07 17:41:13.405630723 -0400
@@ -2,11 +2,11 @@
 
 pragma solidity ^0.8.0;
 
-import "../BaseModule.sol";
+import "../../harness/BaseHarness.sol";
 import "../IRiskManager.sol";
 
 
-contract Installer is BaseModule {
+contract Installer is BaseHarness {
     constructor() BaseModule(MODULEID__INSTALLER) {}
 
     modifier adminOnly {
diff -ruN modules/Liquidation.sol modules/Liquidation.sol
--- modules/Liquidation.sol	2021-09-07 11:35:53.363906379 -0400
+++ modules/Liquidation.sol	2021-10-07 17:41:13.405630723 -0400
@@ -2,11 +2,11 @@
 
 pragma solidity ^0.8.0;
 
-import "../BaseLogic.sol";
+import "../../harness/BaseHarness.sol";
 
 
 /// @notice Liquidate users who are in collateral violation to protect lenders
-contract Liquidation is BaseLogic {
+contract Liquidation is BaseHarness {
     constructor() BaseLogic(MODULEID__LIQUIDATION) {}
 
     // How much of a liquidation is credited to the underlying's reserves.
diff -ruN modules/Markets.sol modules/Markets.sol
--- modules/Markets.sol	2021-09-07 11:35:53.363906379 -0400
+++ modules/Markets.sol	2021-10-07 17:41:13.405630723 -0400
@@ -9,7 +9,6 @@
 
 /// @notice Activating and querying markets, and maintaining entered markets lists
 contract Markets is BaseLogic {
-    constructor() BaseLogic(MODULEID__MARKETS) {}
 
     /// @notice Create an Euler pool and associated EToken and DToken addresses.
     /// @param underlying The address of an ERC20-compliant token. There must be an initialised uniswap3 pool for the underlying/reference asset pair.
@@ -72,7 +71,7 @@
         assetStorage.interestAccumulator = INITIAL_INTEREST_ACCUMULATOR;
 
 
-        emit MarketActivated(underlying, childEToken, childDToken);
+        // emit MarketActivated(underlying, childEToken, childDToken);
 
         return childEToken;
     }
@@ -93,7 +92,7 @@
         pTokenLookup[pTokenAddr] = underlying;
         reversePTokenLookup[underlying] = pTokenAddr;
 
-        emit PTokenActivated(underlying, pTokenAddr);
+        // emit PTokenActivated(underlying, pTokenAddr);
 
         doActivateMarket(pTokenAddr);
 
@@ -164,7 +163,7 @@
     /// @notice Retrieves the current interest rate for an asset
     /// @param underlying Token address
     /// @return The interest rate in yield-per-second, scaled by 10**27
-    function interestRate(address underlying) external view returns (int96) {
+    function interestRate(address underlying) external view returns (uint96) {
         AssetStorage storage assetStorage = eTokenLookup[underlyingLookup[underlying].eTokenAddress];
 
         return assetStorage.interestRate;
diff -ruN modules/RiskManager.sol modules/RiskManager.sol
--- modules/RiskManager.sol	2021-09-07 11:38:22.724302735 -0400
+++ modules/RiskManager.sol	2021-10-07 17:41:13.405630723 -0400
@@ -2,7 +2,7 @@
 
 pragma solidity ^0.8.0;
 
-import "../BaseLogic.sol";
+import "../../harness/BaseHarness.sol";
 import "../IRiskManager.sol";
 import "../vendor/TickMath.sol";
 
@@ -20,7 +20,7 @@
 }
 
 
-contract RiskManager is IRiskManager, BaseLogic {
+contract RiskManager is IRiskManager, BaseHarness {
     // Construction
 
     address immutable referenceAsset;
diff -ruN Storage.sol Storage.sol
--- Storage.sol	2021-09-07 11:35:53.363906379 -0400
+++ Storage.sol	2021-10-07 17:41:13.405630723 -0400
@@ -38,7 +38,7 @@
     }
 
     mapping(address => AccountStorage) accountLookup;
-    mapping(address => address[MAX_POSSIBLE_ENTERED_MARKETS]) marketsEntered;
+    mapping(address => address[]) marketsEntered;
 
 
 
@@ -65,7 +65,7 @@
         uint40 lastInterestAccumulatorUpdate;
         uint8 underlyingDecimals; // Not dynamic, but put here to live in same storage slot
         uint32 interestRateModel;
-        int96 interestRate;
+        uint96 interestRate;
         uint32 reserveFee;
         uint16 pricingType;
         uint32 pricingParameters;
@@ -86,9 +86,9 @@
         mapping(address => mapping(address => uint)) dTokenAllowance;
     }
 
-    mapping(address => AssetConfig) internal underlyingLookup; // underlying => AssetConfig
-    mapping(address => AssetStorage) internal eTokenLookup; // EToken => AssetStorage
-    mapping(address => address) internal dTokenLookup; // DToken => EToken
-    mapping(address => address) internal pTokenLookup; // PToken => underlying
-    mapping(address => address) internal reversePTokenLookup; // underlying => PToken
+    mapping(address => AssetConfig)  public underlyingLookup; // underlying => AssetConfig
+    mapping(address => AssetStorage) public eTokenLookup; // EToken => AssetStorage
+    mapping(address => address) public dTokenLookup; // DToken => EToken
+    mapping(address => address) public pTokenLookup; // PToken => underlying
+    mapping(address => address) public reversePTokenLookup; // underlying => PToken
 }
